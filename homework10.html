<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Advanced Poisson Process Simulator</title>

<!-- Chart.js CDN -->
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

<style>
body { font-family: Arial, sans-serif; max-width: 1000px; margin: 20px auto; }
input { padding: 6px; width: 120px; }
button { padding: 8px 12px; margin-top: 10px; cursor: pointer; }
canvas { background: #fff; margin-top: 20px; border: 1px solid #ccc; }
h3 { margin-top: 40px; }
</style>
</head>
<body>

<h2>Poisson Process – Full Simulation</h2>

<label>Rate λ: <input id="lambda" type="number" value="5" step="0.1"></label>
<label>Subintervals n: <input id="n" type="number" value="5000"></label>
<label>Paths: <input id="paths" type="number" value="5"></label>

<br><br>
<button onclick="runSimulation()">Run Simulation</button>

<h3>Sample Paths</h3>
<canvas id="pathChart" width="800" height="400"></canvas>

<h3>Histogram of Total Counts</h3>
<canvas id="histChart" width="800" height="350"></canvas>

<h3>Waiting Time Distribution</h3>
<canvas id="waitChart" width="800" height="350"></canvas>

<script>
let pathChart, histChart, waitChart;

/* Utility */
function exponentialPDF(lambda, x) {
    return lambda * Math.exp(-lambda * x);
}

function runSimulation() {
    const lambda = parseFloat(document.getElementById("lambda").value);
    const n = parseInt(document.getElementById("n").value);
    const paths = parseInt(document.getElementById("paths").value);
    const p = lambda / n;

    let samplePaths = [];
    let finalCounts = [];
    let waitingTimes = [];

    for (let k = 0; k < paths; k++) {
        let count = 0;
        let cumulative = [];
        let lastEvent = 0;

        for (let i = 0; i < n; i++) {
            if (Math.random() < p) {
                count++;
                let time = i / n;
                waitingTimes.push(time - lastEvent);
                lastEvent = time;
            }
            cumulative.push(count);
        }

        samplePaths.push(cumulative);
        finalCounts.push(count);
    }

    drawPaths(samplePaths);
    drawHistogram(finalCounts, lambda);
    drawWaitingTimes(waitingTimes, lambda);
}

/* Draw Multiple Sample Paths */
function drawPaths(samplePaths) {
    const n = samplePaths[0].length;
    const labels = [...Array(n).keys()].map(i => i / n);

    const datasets = samplePaths.map((path, i) => ({
        label: "Path " + (i+1),
        data: path,
        borderWidth: 2,
        fill: false,
        tension: 0.15
    }));

    if (pathChart) pathChart.destroy();
    pathChart = new Chart(document.getElementById("pathChart"), {
        type: 'line',
        data: { labels, datasets },
        options: {
            plugins: { legend: { display: false }},
            scales: {
                x: { title: { display: true, text: "Time (t)" } },
                y: { title: { display: true, text: "N(t)" }, beginAtZero: true }
            }
        }
    });
}

/* Draw Histogram + Poisson PMF */
function drawHistogram(counts, lambda) {
    const maxCount = Math.max(...counts);
    const freq = {};
    counts.forEach(c => freq[c] = (freq[c] || 0) + 1);

    const labels = [...Array(maxCount+1).keys()];
    const empirical = labels.map(k => freq[k] || 0);

    const theoretical = labels.map(k =>
        counts.length * (Math.exp(-lambda) * Math.pow(lambda, k) / factorial(k))
    );

    if (histChart) histChart.destroy();
    histChart = new Chart(document.getElementById("histChart"), {
        type: 'bar',
        data: {
            labels,
            datasets: [
                { label: "Empirical", data: empirical, backgroundColor: "rgba(0,120,255,0.6)" },
                { label: "Poisson(λ)", data: theoretical, type: "line", borderColor: "red", borderWidth: 2 }
            ]
        },
        options: { scales: { y: { beginAtZero: true } } }
    });
}

/* Draw Waiting Time Distribution + Exponential(λ) curve */
function drawWaitingTimes(wtimes, lambda) {
    const bins = 30;
    const maxT = Math.max(...wtimes);
    const width = maxT / bins;

    let hist = new Array(bins).fill(0);
    wtimes.forEach(t => {
        const b = Math.min(bins - 1, Math.floor(t / width));
        hist[b]++;
    });

    const labels = [...Array(bins).keys()].map(i => (i * width).toFixed(3));
    const theoretical = labels.map(x => exponentialPDF(lambda, parseFloat(x)) * wtimes.length * width);

    if (waitChart) waitChart.destroy();
    waitChart = new Chart(document.getElementById("waitChart"), {
        type: 'bar',
        data: {
            labels,
            datasets: [
                { label: "Empirical waiting times", data: hist, backgroundColor: "rgba(0,180,100,0.6)" },
                { label: "λ e^{-λt}", data: theoretical, type: "line", borderColor:"black" }
            ]
        },
        options: { scales: { y: { beginAtZero: true } } }
    });
}

/* Factorial helper */
function factorial(n) {
    if (n === 0 || n === 1) return 1;
    let r = 1;
    for (let i = 2; i <= n; i++) r *= i;
    return r;
}
</script>

</body>
</html>
